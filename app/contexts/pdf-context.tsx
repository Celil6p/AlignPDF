import React, {
  createContext,
  useState,
  useContext,
  useCallback,
  useEffect,
} from "react";
import placeholder from "public/placeholder-pdf-image.png";
import { PdfFile, MergeOrderItem } from "./types/pdf";
import { db } from "./db";
import { PDFDocument } from "pdf-lib";
import { getPage } from "~/lib/get-page";

interface PdfProviderProps {
  children: React.ReactNode;
}

type PdfContextType = {
  mergeOrder: MergeOrderItem[];
  pdfFiles: PdfFile[];
  addPdfFile: (file: File) => void;
  createSubFile: (pdfId: number, range: [number, number]) => void;
  mergePdfs: () => Promise<Blob | null>; // Returns a new merged PDF
  removePdf: (pdfId: number) => void;
  addPdfToMergeOrder: (type: "pdf" | "subPdf", pdfId: number) => void;
  removeSubPdf: (subFileId: number, parentPdfId: number) => Promise<void>;
  getFirstPage: (pdf: PdfFile) => Promise<string>;
};

const PdfContext = createContext<PdfContextType | undefined>(undefined);

export const usePdf = () => {
  const context = useContext(PdfContext);
  if (!context) {
    throw new Error("usePdf must be used within a PdfProvider");
  }
  return context;
};

export const PdfProvider = ({ children }: PdfProviderProps) => {
  const [pdfFiles, setPdfFiles] = useState<PdfFile[]>([]);
  const [mergeOrder, setMergeOrder] = useState<MergeOrderItem[]>([]);

  useEffect(() => {
    const loadPdfFiles = async () => {
      const allPdfFiles = await db.pdfFiles.toArray();
      setPdfFiles(allPdfFiles);
    };
    loadPdfFiles();
  }, []);

  /*************************************************************************************************************************************** */

  const addPdfFile = useCallback(async (file: File) => {
    try {
      // Read the file as an ArrayBuffer
      const arrayBuffer = await file.arrayBuffer();

      // Load the PDF document
      const pdfDoc = await PDFDocument.load(arrayBuffer);

      // Get the total number of pages
      const numberOfPages = pdfDoc.getPageCount();

      const newPdf = {
        title: file.name,
        file,
        size: file.size,
        pages: numberOfPages, // Set the number of pages
        subFiles: [],
      };

      // Add the new PdfFile to the Dexie database
      const withId = await db.pdfFiles.add(newPdf);

      // Update the local state with the new PdfFile, including the ID generated by Dexie
      setPdfFiles((prev) => [...prev, { ...newPdf, id: withId }]);
    } catch (error) {
      console.error("Error processing the PDF file:", error);
      // Handle the error appropriately
      alert("Error processing the PDF file.");
    }
  }, []);

  /*************************************************************************************************************************************** */

  const createSubFile = useCallback(
    async (pdfId: number, range: [number, number]) => {
      const pdfIndex = pdfFiles.findIndex((pdf) => pdf.id === pdfId);
      if (pdfIndex !== -1) {
        // Creating the new subfile object
        const newSubFile = {
          parentPdfId: pdfId,
          range,
        };

        // Add the new subfile to the Dexie database
        const subFileId = await db.subFiles.add(newSubFile);

        // Update the local state to include the new subfile
        setPdfFiles((prev) => {
          const newPdfFiles = [...prev];
          const updatedPdf = { ...newPdfFiles[pdfIndex] };
          if (!updatedPdf.subFiles) {
            updatedPdf.subFiles = []; // Initialize subFiles array if it does not exist
          }
          updatedPdf.subFiles.push({ ...newSubFile, id: subFileId }); // Add the new subfile with its ID
          newPdfFiles[pdfIndex] = updatedPdf;

          // Update the parent PDF file in the Dexie database to include the new subfile ID
          db.pdfFiles.update(pdfId, { subFiles: updatedPdf.subFiles });

          // Update subfile image storage

          return newPdfFiles;
        });
      }
    },
    [pdfFiles, setPdfFiles]
  );

  /*************************************************************************************************************************************** */

  const getFirstPage = async (pdf: PdfFile): Promise<string> => {
    if (!pdf.id) {
      console.error("Error: PDF file is missing an ID.");
      return placeholder;
    }

    try {
      // Check if the image URL is already stored in Dexie
      const storedImage = await db.firstPageImages.get(pdf.id);
      if (storedImage) {
        return storedImage.imageUrl;
      }

      // Fetch the first page and store the new image URL in Dexie
      const url = await getPage(pdf, 1);
      await db.firstPageImages.put({ pdfId: pdf.id, imageUrl: url });
      return url;
    } catch (error) {
      console.error("Error fetching first page of PDF", error);
      return placeholder;
    }
  };

  const mergePdfs = useCallback(async (): Promise<Blob | null> => {
    try {
      const mergedPdfDoc = await PDFDocument.create();
      const mergeOrderItems = await db.mergeOrders.orderBy("order").toArray();

      for (const item of mergeOrderItems) {
        let pdfDoc;

        if (item.type === "pdf") {
          const pdfFile = await db.pdfFiles.get(item.pdfId);
          if (pdfFile && pdfFile.file instanceof File) {
            const arrayBuffer = await pdfFile.file.arrayBuffer();
            pdfDoc = await PDFDocument.load(arrayBuffer);
            const pagesToCopy = pdfDoc.getPageIndices(); // All pages for a full PDF
            const pages = await mergedPdfDoc.copyPages(pdfDoc, pagesToCopy);
            pages.forEach((page) => mergedPdfDoc.addPage(page));
          }
        } else if (item.type === "subPdf") {
          const subFile = await db.subFiles.get(item.pdfId);
          if (subFile) {
            const parentPdfFile = await db.pdfFiles.get(subFile.parentPdfId);
            if (parentPdfFile && parentPdfFile.file instanceof File) {
              const arrayBuffer = await parentPdfFile.file.arrayBuffer();
              pdfDoc = await PDFDocument.load(arrayBuffer);
              const start = Math.max(subFile.range[0] - 1, 0);
              const end = Math.min(
                subFile.range[1] - 1,
                pdfDoc.getPageCount() - 1
              );
              const pagesToCopy = Array.from(
                { length: end - start + 1 },
                (_, i) => start + i
              );
              const pages = await mergedPdfDoc.copyPages(pdfDoc, pagesToCopy);
              pages.forEach((page) => mergedPdfDoc.addPage(page));
            }
          }
        }

        if (!pdfDoc) {
          console.error(`Failed to load PDF document for ID: ${item.pdfId}`);
        }
      }

      const mergedPdfBytes = await mergedPdfDoc.save();
      return new Blob([mergedPdfBytes], { type: "application/pdf" });
    } catch (error) {
      console.error("Error merging PDF files:", error);
      return null;
    }
  }, []); // Include relevant dependencies

  /*************************************************************************************************************************************** */

  const removePdf = useCallback(
    async (pdfId: number) => {
      try {
        // Remove the Sub-PDFs from the merge order
        const subFiles = await db.subFiles
          .where({ parentPdfId: pdfId })
          .toArray();
        const subFileIds = subFiles.map((subFile) => subFile.id);
        for (const subFileId of subFileIds) {
          await db.mergeOrders
            .where({ type: "subPdf", pdfId: subFileId })
            .delete();
        }
        // Remove the PDF from the merge order
        await db.mergeOrders.where({ type: "pdf", pdfId }).delete();

        // Delete the PDF from the Dexie database
        await db.pdfFiles.delete(pdfId);

        // Optionally, if you store related data (like firstPageImages), delete those too
        await db.firstPageImages.where({ pdfId }).delete();

        // Optionally, if you store related data (like subFiles), delete those too
        await db.subFiles.where({ parentPdfId: pdfId }).delete();

        // Remove subPdfImages
        await db.subFileImages.where({ parentPdfId: pdfId }).delete();

        // Update the local state to remove the PDF
        setPdfFiles((prevPdfFiles) =>
          prevPdfFiles.filter((pdf) => pdf.id !== pdfId)
        );
      } catch (error) {
        console.error("Error removing PDF file:", error);
        // Optionally, handle the error in the UI (e.g., show an error message)
      }
    },
    [pdfFiles, setPdfFiles]
  );

  const removeSubPdf = useCallback(
    async (subFileId: number, parentPdfId: number) => {
      try {
        // Remove the subfile from IndexedDB
        await db.subFiles.delete(subFileId);
        await db.mergeOrders
          .where({ type: "subPdf", pdfId: subFileId })
          .delete();
        await db.subFileImages.delete(subFileId);

        // Update the corresponding entry in IndexedDB
        const parentPdf = await db.pdfFiles.get(parentPdfId);
        if (parentPdf && parentPdf.subFiles) {
          const updatedSubFiles = parentPdf.subFiles.filter(
            (subFile) => subFile.id !== subFileId
          );
          await db.pdfFiles.update(parentPdfId, { subFiles: updatedSubFiles });

          // Update the pdfFiles state
          setPdfFiles((prevPdfFiles) => {
            return prevPdfFiles.map((pdf) => {
              if (pdf.id === parentPdfId) {
                return { ...pdf, subFiles: updatedSubFiles };
              }
              return pdf;
            });
          });
        }
      } catch (error) {
        console.error("Error removing sub PDF file:", error);
      }
    },
    [setPdfFiles]
  );

  /*************************************************************************************************************************************** */

  const fetchAndUpdateMergeOrder = useCallback(async () => {
    try {
      const fetchedMergeOrder = await db.mergeOrders.orderBy("order").toArray();
      setMergeOrder(fetchedMergeOrder);
    } catch (error) {
      console.error("Error fetching merge order:", error);
    }
  }, []);

  useEffect(() => {
    fetchAndUpdateMergeOrder();
  }, [fetchAndUpdateMergeOrder]);

  const addPdfToMergeOrder = useCallback(
    async (type: "pdf" | "subPdf", pdfId: number) => {
      try {
        const currentOrderCount = await db.mergeOrders.count();
        const newOrderItem = {
          type: type,
          pdfId: pdfId,
          order: currentOrderCount,
        };
        await db.mergeOrders.add(newOrderItem);
        setMergeOrder((prev) => [...prev, newOrderItem]);
        await fetchAndUpdateMergeOrder();
      } catch (error) {
        console.error("Error adding to merge order:", error);
        // Handle the error appropriately
      }
    },
    [fetchAndUpdateMergeOrder]
  );

  /*************************************************************************************************************************************** */

  // Render the PdfProvider with the children components
  return (
    <PdfContext.Provider
      value={{
        mergeOrder,
        pdfFiles,
        addPdfFile,
        createSubFile,
        mergePdfs,
        removePdf,
        addPdfToMergeOrder,
        removeSubPdf,
        getFirstPage,
      }}
    >
      {children}
    </PdfContext.Provider>
  );
};
