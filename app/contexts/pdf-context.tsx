import React, { createContext, useState, useContext, useCallback, useEffect } from 'react';
import { PdfFile } from './types/pdf';
import { db } from './db';
import { PDFDocument } from "pdf-lib";

interface PdfProviderProps {
  children: React.ReactNode;
}


type PdfContextType = {
  pdfFiles: PdfFile[];
  addPdfFile: (file: File) => void;
  createSubFile: (pdfId: number, range: [number, number]) => void;
  mergePdfs: (subFileIds: string[]) => Promise<File | null>; // Returns a new merged PDF
  removePdf: (pdfId: number) => void;
  // Add other functions and state as needed
};


const PdfContext = createContext<PdfContextType | undefined>(undefined);

export const usePdf = () => {
  const context = useContext(PdfContext);
  if (!context) {
    throw new Error('usePdf must be used within a PdfProvider');
  }
  return context;
};

export const PdfProvider = ({ children }: PdfProviderProps) => {
  const [pdfFiles, setPdfFiles] = useState<PdfFile[]>([]);

  useEffect(() => {
    const loadPdfFiles = async () => {
      const allPdfFiles = await db.pdfFiles.toArray();
      setPdfFiles(allPdfFiles);
    };
    loadPdfFiles();
  }, []);


  const addPdfFile = useCallback(async (file: File) => {
    try {
      // Read the file as an ArrayBuffer
      const arrayBuffer = await file.arrayBuffer();
  
      // Load the PDF document
      const pdfDoc = await PDFDocument.load(arrayBuffer);
  
      // Get the total number of pages
      const numberOfPages = pdfDoc.getPageCount();
  
      const newPdf = {
        title: file.name,
        file,
        size: file.size,
        pages: numberOfPages, // Set the number of pages
        subFiles: [],
      };
  
      // Add the new PdfFile to the Dexie database
      const withId = await db.pdfFiles.add(newPdf);
    
      // Update the local state with the new PdfFile, including the ID generated by Dexie
      setPdfFiles(prev => [...prev, { ...newPdf, id: withId }]);
    } catch (error) {
      console.error("Error processing the PDF file:", error);
      // Handle the error appropriately
      alert("Error processing the PDF file.");
    }
  }, []);


  const createSubFile = useCallback(async (pdfId: number, range: [number, number]) => {
    const pdfIndex = pdfFiles.findIndex(pdf => pdf.id === pdfId);
    if (pdfIndex !== -1) {
      // Creating the new subfile object
      const newSubFile = {
        parentPdfId: pdfId,
        range
      };
  
      // Add the new subfile to the Dexie database
      const subFileId = await db.subFiles.add(newSubFile);
  
      // Update the local state to include the new subfile
      setPdfFiles(prev => {
        const newPdfFiles = [...prev];
        const updatedPdf = { ...newPdfFiles[pdfIndex] };
        if (!updatedPdf.subFiles) {
          updatedPdf.subFiles = []; // Initialize subFiles array if it does not exist
        }
        updatedPdf.subFiles.push({ ...newSubFile, id: subFileId }); // Add the new subfile with its ID
        newPdfFiles[pdfIndex] = updatedPdf;
  
        // Update the parent PDF file in the Dexie database to include the new subfile ID
        db.pdfFiles.update(pdfId, { subFiles: updatedPdf.subFiles });
  
        return newPdfFiles;
      });
    }
  }, [pdfFiles]);



  const mergePdfs = useCallback(async (subFileIds: string[]): Promise<File | null> => {
    try {
      // Implement the logic to merge the PDFs using the subFileIds
      // Return a new merged PDF File object
      return null;
    } catch (error) {
      console.error(error);
      return null;
    }
  }, [pdfFiles]);



  const removePdf = useCallback(async (pdfId: number) => {
    try {
        // Delete the PDF from the Dexie database
        await db.pdfFiles.delete(pdfId);

        // Optionally, if you store related data (like firstPageImages), delete those too
        await db.firstPageImages.where({ pdfId }).delete();

        // Optionally, if you store related data (like subFiles), delete those too
        await db.subFiles.where({ parentPdfId: pdfId }).delete();

        // Update the local state to remove the PDF
        setPdfFiles(prevPdfFiles => prevPdfFiles.filter(pdf => pdf.id !== pdfId));
    } catch (error) {
        console.error('Error removing PDF file:', error);
        // Optionally, handle the error in the UI (e.g., show an error message)
    }
}, [setPdfFiles]);



  // Render the PdfProvider with the children components
  return (
    <PdfContext.Provider value={{ pdfFiles, addPdfFile, createSubFile, mergePdfs, removePdf }}>
      {children}
    </PdfContext.Provider>
  );
};
